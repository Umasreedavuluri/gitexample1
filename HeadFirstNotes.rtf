{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset1 Cambria Math;}{\f2\fnil\fcharset0 Cambria Math;}{\f3\fnil Calibri;}{\f4\fnil\fcharset2 Symbol;}}
{\colortbl ;\red255\green0\blue0;\red0\green0\blue255;}
{\*\generator Riched20 10.0.16299}{\*\mmathPr\mmathFont1\mwrapIndent1440 }\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs24\lang9 Chapter 1\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b0 Versions of Android have a version number, API level, and code name.\par
{\pntext\f4\'B7\tab} Android Studio is a special version of IntelliJ IDEA that interfaces with the Android Software Development Kit (SDK) and the gradle build system.\par
{\pntext\f4\'B7\tab} A typical Android app is comprised of activities, layouts, and resource files.\par
{\pntext\f4\'B7\tab} Layouts describe what your app looks like. They\rquote re held in the app/src/main/res/layout folder. \par
{\pntext\f4\'B7\tab}Activities describe what you app does, and how it interacts with the user. The activities you write are held in the app/src/main/java folder. \par
{\pntext\f4\'B7\tab}strings.xml contains string name/value pairs. It\rquote s used to separate out text values from the layouts and activities, and supports localization. \par
{\pntext\f4\'B7\tab}AndroidManifest.xml contains information about the app itself. It lives in the app/src/main folder. \par
{\pntext\f4\'B7\tab}An AVD is an Android V irtual Device. It runs in the Android emulator and mimics a physical Android device. \par
{\pntext\f4\'B7\tab}An APK is an Android application package. It\rquote s like a JAR file for Android apps, and contains your app bytecode, libraries, and resources. You install an app on a device by installing the APK.\par
{\pntext\f4\'B7\tab} Android apps run in separate processes using the Android runtime (ART). \par
{\pntext\f4\'B7\tab}RelativeLayout is used to place GUI components in relative positions in a layout.\par
{\pntext\f4\'B7\tab} The TextView element is used for displaying text.\par

\pard\sa200\sl276\slmult1\par
\b Chapter2 \b0\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 If you want a method to respond to a button click, it must be public, have a void return type, and take a single View parameter . \par
{\pntext\f4\'B7\tab}The View parameter in the method may seem unusual at first glance, but there\rquote s a good reason for it being there.\par
{\pntext\f4\'B7\tab} The parameter refers to the GUI component that triggers the method (in this case, the button). As we mentioned earlier, GUI components such as buttons and text views are all types of View. \par

\pard\sa200\sl276\slmult1 We can get a handle for our two GUI components using a method called findViewById().\par
 The findViewById() method takes the ID of the GUI component as a parameter, and returns a View object. \par
You then cast the return value to the correct type of GUI component (for example, a TextView or a Button). \par
\b R notes\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b0 R.java is a special Java file that gets generated by the Android tools whenever you create or build your app. \par
{\pntext\f4\'B7\tab}It lives within the app/build/generated/source/r/debug folder in your project in a package with the same name as the package of your app. \par
{\pntext\f4\'B7\tab}Android uses R to keep track of the resources used within the app, and among other things it enables you to get references to GUI components from within your activity code.\par
{\pntext\f4\'B7\tab}\b  R is a special Java class that enables you to retrieve references to resources in your app. \par
{\pntext\f4\'B7\tab}If you open up R.java, you\rquote ll see that it contains a series of inner classes, one for each type of resource. Each resource of that type is referenced within the inner class. \par

\pard\sa200\sl276\slmult1\par
\par
\b0 The Button element is used to add a button.\par
 The Spinner element is used to add a spinner. A spinner is a drop-down list of values.\par
 All GUI components are types of view. They inherit from the Android View class. \par
Add an array of string values using: <string-array name="array">    <item>string1</item>    ... </string-array> Reference a string-array in the layout using: "@array/array_name" \par
Make a button call a method when clicked by adding the following to the layout: android:onClick="clickMethod"\par
There needs to be a corresponding method in the activity: public void clickMethod(View view)\{ \} R.java is generated for you.\par
 It enables you to get references for layouts, GUI components, Strings, and other resources in your Java code.\par
 Use findViewById() to get a reference to a view. \par
Use setText() to set the text in a view.\par
 Use getSelectedItem() to get the selected item in a spinner. \par
Add a custom class to an Android project by going to File menu\f1\u8594?\f0 New...\f1\u8594?\f0 Java Class.\par
\par
\b Intent\par
\par
\b0 Intent is a type of message.\par
Whenever\f2  \f0 you\f2  \f0 want\f2  \f0 an\f2  \f0 activity\f2  \f0 to\f2  \f0 start\f2  \f0 a\f2  \f0 second\f2  \f0 activity\f2 , \f0 you\f2  \f0 use\f2  \f0 an\f2  \f0 intent\f2 .\par
 \f0 You\f2  \f0 can\f2  \f0 think\f2  \f0 of\f2  \f0 an\f2  \f0 intent\f2  \f0 as\f2  \f0 an\f2  \f0\ldblquote intent\f2  \f0 to\f2  \f0 do\f2  \f0 something\rdblquote\f2 .\par
 \f0 It\rquote s\f2  \f0 a\f2  \f0 type\f2  \f0 of\f2  \f0 message\f2  \f0 that\f2  \f0 allows\f2  \f0 you\f2  \f0 to\f2  \f0 bind\f2  \f0 separate\f2  \f0 objects\f2  (\f0 such\f2  \f0 as\f2  \f0 activities\f2 ) \f0 together\f2  \f0 at\f2  \f0 runtime\f2 . \par
\f0 If\f2  \f0 one\f2  \f0 activity\f2  \f0 wants\f2  \f0 to\f2  \f0 start\f2  \f0 a\f2  \f0 second\f2  \f0 activity\f2 , \f0 it\f2  \f0 does\f2  \f0 it\f2  \f0 by\f2  \f0 sending\f2  \f0 an\f2  \f0 intent\f2  \f0 to\f2  \f0 Android\f2 . \f0 Android\f2  \f0 will\f2  \f0 start\f2  \f0 the\f2  \f0 second\f2  \f0 activity\f2  \f0 and\f2  \f0 pass\f2  \f0 it\f2  \f0 the\f2  \f0 intent\f2 . \f0\par
You\f2  \f0 start\f2  \f0 an\f2  \f0 activity\f2  \f0 by\f2  \f0 creating\f2  \f0 an\f2  \f0 intent\f2  \f0 and\f2  \f0 using\f2  \f0 it\f2  \f0 in\f2  \f0 the\f2  \f0 startActivity\f2 () \f0 method\f2 .\par
Intent intent = new Intent(this,Target.class);\par
The first parameter tells Android which object the intent is from, and you can use the word this to refer to the current activity .\par
 The second parameter is the class name of the activity that needs to receive the intent. \par
Then say startActivity(intent);\par
You can add extra information to this intent that can be picked up by the activity you\rquote re targeting so it can react in some way.\par
 To do this, you use the putExtra() method\par
 intent.putExtra("message", value);\par
\b Retrieve Intent Information\par
\b0 Use getIntent\par
Intent intent = getIntent();\par
String str = intent.getStringExtra("message");\par
\par
\b Chapter 3\b0\par
\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 A task is two or more activities chained together. \par
{\pntext\f4\'B7\tab}The <EditText> element defines an editable text field for entering text. It inherits from the Android View class. \par
{\pntext\f4\'B7\tab}You can add a new activity in Android Studio by choosing File \f1\u8594? New... \u8594? Activity.\par
{\pntext\f4\'B7\tab} Each activity you create must have an entry in AndroidManifest.xml. \par
{\pntext\f4\'B7\tab}An intent is a type of message that Android components use to communicate with one another.\par
{\pntext\f4\'B7\tab} An explicit intent explicitly specifies the component the intent is targeted at. You create an explicit intent using Intent intent = new Intent(this, Target.class); \par
{\pntext\f4\'B7\tab}\f0 To\f2  \f0 start\f2  \f0 an\f2  \f0 activity\f2 , \f0 call\f2  \f0 startActivity\f2 (\f0 intent\f2 ). \f0 If\f2  \f0 no\f2  \f0 activities\f2  \f0 are\f2  \f0 found\f2 , \f0 it\f2  \f0 throws\f2  \f0 an\f2  \f0 ActivityNotFoundException\f2 . \par
{\pntext\f4\'B7\tab}\f0 Use\f2  \f0 the\f2  \f0 putExtra\f2 () \f0 method\f2  \f0 to\f2  \f0 add\f2  \f0 extra\f2  \f0 information\f2  \f0 to\f2  \f0 an\f2  \f0 intent\f2 . \par
{\pntext\f4\'B7\tab}\f0 Use\f2  \f0 the\f2  \f0 getIntent\f2 () \f0 method\f2  \f0 to\f2  \f0 retrieve\f2  \f0 the\f2  \f0 intent\f2  \f0 that\f2  \f0 started\f2  \f0 the\f2  \f0 activity\f2 . \par
{\pntext\f4\'B7\tab}\f0 Use\f2  \f0 the\f2  \f0 get*Extra\f2 () \f0 methods\f2  \f0 to\f2  \f0 retrieve\f2  \f0 extra\f2  \f0 information\f2  \f0 associated\f2  \f0 with\f2  \f0 the\f2  \f0 intent\f2 . \f0 getStringExtra\f2 () \f0 retrieves\f2  \f0 a\f2  \f0 String\f2 , \f0 getIntExtra\f2 () \f0 retrieves\f2  \f0 an\f2  \f0 int\f2 , \f0 and\f2  \f0 so\f2  \f0 on\f2 . \par
{\pntext\f4\'B7\tab}\f0 An\f2  \f0 activity\f2  \f0 action\f2  \f0 describes\f2  \f0 a\f2  \f0 standard\f2  \f0 operational\f2  \f0 action\f2  \f0 an\f2  \f0 activity\f2  \f0 can\f2  \f0 perform\f2 . \f0 To\f2  \f0 send\f2  \f0 a\f2  \f0 message\f2 , \f0 use\f2  \f0 Intent\f2 .\f0 ACTION\f2 _\f0 SEND\f2 . \par
{\pntext\f4\'B7\tab}\f0 To\f2  \f0 create\f2  \f0 an\f2  \f0 implicit\f2  \f0 intent\f2  \f0 that\f2  \f0 specifies\f2  \f0 an\f2  \f0 action\f2 , \f0 use\f2  \f0 Intent\f2  \f0 intent\f2  = \f0 new\f2  \f0 Intent\f2 (\f0 action\f2 ); \par
{\pntext\f4\'B7\tab}\f0 To\f2  \f0 describe\f2  \f0 the\f2  \f0 type\f2  \f0 of\f2  \f0 data\f2  \f0 in\f2  \f0 the\f2  \f0 intent\f2 , \f0 use\f2  \f0 the\f2  \f0 setType\f2 () \f0 method\f2 .\par
{\pntext\f4\'B7\tab}\f0 Android\f2  \f0 resolves\f2  \f0 intents\f2  \f0 based\f2  \f0 on\f2  \f0 the\f2  \f0 named\f2  \f0 component\f2 , \f0 action\f2 , \f0 type\f2  \f0 of\f2  \f0 data\f2 , \f0 and\f2  \f0 categories\f2  \f0 specified\f2  \f0 in\f2  \f0 the\f2  \f0 intent\f2 . \f0 It\f2  \f0 compares\f2  \f0 the\f2  \f0 contents\f2  \f0 of\f2  \f0 the\f2  \f0 intent\f2  \f0 with\f2  \f0 the\f2  \f0 intent\f2  \f0 filters\f2  \f0 in\f2  \f0 each\f2  \f0 app\rquote s\f2  \f0 AndroidManifest\f2 .\f0 xml\f2 .\par
{\pntext\f4\'B7\tab} \f0 An\f2  \f0 activity\f2  \f0 must\f2  \f0 have\f2  \f0 a\f2  \f0 category\f2  \f0 of\f2  \f0 DEFAULT\f2  \f0 if\f2  \f0 it\f2  \f0 is\f2  \f0 to\f2  \f0 receive\f2  \f0 an\f2  \f0 implicit\f2  \f0 intent\f2 . \par
{\pntext\f4\'B7\tab}\f0 The\f2  \f0 createChooser\f2 () \f0 method\f2  \f0 allows\f2  \f0 you\f2  \f0 to\f2  \f0 override\f2  \f0 the\f2  \f0 default\f2  \f0 Android\f2  \f0 activity\f2  \f0 chooser\f2  \f0 dialog\f2 . \f0 It\f2  \f0 allows\f2  \f0 you\f2  \f0 to\f2  \f0 specify\f2  \f0 a\f2  \f0 title\f2  \f0 for\f2  \f0 the\f2  \f0 dialog\f2 , \f0 and\f2  \f0 doesn\rquote t\f2  \f0 give\f2  \f0 the\f2  \f0 user\f2  \f0 the\f2  \f0 option\f2  \f0 of\f2  \f0 setting\f2  \f0 a\f2  \f0 default\f2  \f0 activity\f2 . \f0 If\f2  \f0 no\f2  \f0 activities\f2  \f0 can\f2  \f0 receive\f2  \f0 the\f2  \f0 intent\f2  \f0 it\f2  \f0 is\f2  \f0 passed\f2 , \f0 it\f2  \f0 displays\f2  \f0 a\f2  \f0 message\f2 . \f0 The\f2  \f0 createChooser\f2 () \f0 method\f2  \f0 returns\f2  \f0 an\f2  \f0 Intent\f2 . \par
{\pntext\f4\'B7\tab}\f0 You\f2  \f0 retrieve\f2  \f0 the\f2  \f0 value\f2  \f0 of\f2  \f0 a\f2  \f0 string\f2  \f0 resource\f2  \f0 using\f2  \f0 getString\f2 (\f0 R\f2 .\f0 string\f2 .\f0 stringname\f2 );\f0\par

\pard\sa200\sl276\slmult1\b\fs28\lang9 Chapter 4\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b0 Each app runs in its own process by default.\par
{\pntext\f4\'B7\tab}Only the main thread can update the user interface. \par
{\pntext\f4\'B7\tab}Use a Handler to schedule code, or post code to a different thread.\par
{\pntext\f4\'B7\tab} A device configuration change results in the activity being destroyed and re-created. Your activity inherits the lifecycle methods from the Android Activity class.\par
{\pntext\f4\'B7\tab} If you override any of these methods, you need to call up to the method in the superclass.\par
{\pntext\f4\'B7\tab}onSaveInstanceState(Bundle) enables your activity to save its state before the activity gets destroyed.You can use the Bundle to restore state in onCreate(). \par
{\pntext\f4\'B7\tab}You add values to a Bundle using bundle.put*("name", value). You retrieve values from the bundle using bundle.get*("name"). \par
{\pntext\f4\'B7\tab}onCreate() and onDestroy(), deal with the birth and death of the activity. \par
{\pntext\f4\'B7\tab}onRestart(), onStart() and onStop() deal with the visibility of the activity. \par
{\pntext\f4\'B7\tab}onResume() and onPause() deal with when the activity gains and loses the focus\fs24\par

\pard\sa200\sl276\slmult1\par
\b\fs28 Chapter 5\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b0 GUI components are all types of view.They are all subclasses of the android.view.View class. \par
{\pntext\f4\'B7\tab}All layouts are subclasses of the android.view.ViewGroup class. A view group is a type of view that can contain multiple views. \par
{\pntext\f4\'B7\tab}The layout XML file gets converted to a V iewGroup containing a hierarchical tree of views. \par
{\pntext\f4\'B7\tab}A relative layout displays child views relative to other views, or relative to the parent layout.\par
{\pntext\f4\'B7\tab} A linear layout lists views either horizontally or vertically. You specify the direction using the android:orientation attribute. \par
{\pntext\f4\'B7\tab}A grid layout divides the screen into a grid of cells so that you can specify which cell (or cells) each view should occupy. Use android:columnCount to say how many columns there should be. Use android:layout_row and android:layout_column to say which cell you want each view to appear in. Use android:layout_columnSpan to say how many columns the view should spread across. \par
{\pntext\f4\'B7\tab}Use android:padding* attributes to specify how much padding you want there to be around a view. \par
{\pntext\f4\'B7\tab}Use android:layout_weight in a linear layout if you want a view to use up extra space in the layout. android:layout_gravity lets you say where you want views to appear in their available space. \par
{\pntext\f4\'B7\tab}android:gravity lets you say where you want the contents to appear inside the view. \par
{\pntext\f4\'B7\tab}<ToggleButton> defines a toggle button which allows you to choose between two states by clicking a button.\par
{\pntext\f4\'B7\tab} <Switch> defines a switch control that behaves in the same way as a toggle button. It requires API level 14 or above. \par
{\pntext\f4\'B7\tab}<CheckBox> defines a checkbox. To define a group of radio buttons, first use <RadioGroup> to define the radio group. Then put individual radio buttons in the radio group using <RadioButton>. \par
{\pntext\f4\'B7\tab}Use <ImageView> to display an image. <ImageButton> defines a button with no text, just an image. \par
{\pntext\f4\'B7\tab}Add scrollbars using <ScrollView> or <HorizontalScrollView>. \par
{\pntext\f4\'B7\tab}A toast is a pop up message\fs24\par

\pard\sa200\sl276\slmult1\par
\fs28\par
\b Chapter 6\par
\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b0 Sort your ideas for activities into top-level activities, category sactivities, and detail/edit activities. Use the category activities to navigate from the top-level activities to the detail/edit activities. \par
{\pntext\f4\'B7\tab}Image resources go in one or more of the drawable* folders. You reference them in your layout using @drawable/image_name. You access them in your activity code using R.drawable. image_name. \par
{\pntext\f4\'B7\tab}An ImageView holds an image. Add it to your layout using <ImageView>. Use android:src to set its source, and android:contentDescription to give it an accessible label. The equivalent methods in Java are setImageResource() and setContentDescription().\par
{\pntext\f4\'B7\tab} A ListView displays items in a list. Add it to your layout using <ListView>. \par
{\pntext\f4\'B7\tab}Use android:entries in your layout to populate the items in your list views from an array defined in strings.xml.\par
{\pntext\f4\'B7\tab} A ListActivity is an Activity that comes with a ListView. You get a reference to the ListView using getListView().\par
{\pntext\f4\'B7\tab} A ListActivity has its own default layout, but you can replace it with your own. \par
{\pntext\f4\'B7\tab}An adapter acts as a bridge between an AdapterView and a data source. ListViews and Spinners are both types of AdapterView.\par
{\pntext\f4\'B7\tab} An ArrayAdapter is an adapter that works with arrays.\par
{\pntext\f4\'B7\tab} Handle click events on Buttons using android:onClick in the layout code. \par
{\pntext\f4\'B7\tab}Handle click events on a ListView in a ListActivity by implementing the onListItemClick() method.\par
{\pntext\f4\'B7\tab} Handle click events elsewhere by creating a listener and implementing its click event.\par

\pard\sa200\sl276\slmult1\b\par
\fs24 Chapter 7\par
\par
\b0 For different devices same code needs to be run by multiple activities.Rather than duplicate the code in two activities ,we can use fragments.\par
\par
Fragments are like reusable components or subactivities.\par
A fragment is used to control a part of the screen\par
A fragment can be reused between screens.\par
Just like an activity ,a fragment has an associated layout.\par
All fragments must subclass the Fragment class. Our fragment also implements the onCreateView() method. \par
The onCreateView() method gets called each time Android needs the fragment\rquote s layout, and it\rquote s where you say which layout the fragment uses.\par
You use the <fragment> element to add a fragment to an activity\rquote s layout. You specify which fragment using the class attribute and setting it to the fully qualified name of the fragment. \par
\par
Before an activity can talk to its fragment, the activity first needs to get a reference to it. To get a reference to the fragment, you first get a reference to the activity\rquote s fragment manager using the activity\rquote s\par
getFragmentManager() method. You then use its findFragmentById() method to get a reference to the fragment:\par
\b getFragmentManager().findFragmentById(R.id.fragment_id);\par
\fs32 ListFragment\fs24\par
\b0\fs22 A ListFragment is a type of Fragment that\rquote s specializes in working with a ListView . It has a default layout that contains the ListView . \par
\par
There are are a couple of major advantages in using a list fragment to display categories of data: \par
\b 1) \b0 You don\rquote t need to create your own layout. List fragments define their own layout programmatically, so there\rquote s no XML layout for you to create or maintain. The layout the list fragment generates includes a single list view. You access this list view in your activity code using the list fragment\rquote s \b getListView()\b0  method. You need this in order to specify what data should be displayed in the list view. \b\par
2) \b0 You don\rquote t have to implement your own event listener . The \b ListFragment \b0 class is registered as a\b  listener on the list view, and listens for when items in the list view are clicked\b0 . You use the list fragment\rquote s \b onListItemClick() \b0 method to get fragment to respond to clicks. \fs32\par
\b FrameLayout\par
\b0\fs24 A frame layout is a type of view group that\rquote s used to block out an area on the screen. You define it using the <FrameLayout> element. You use it to display single items \f3\emdash  in our case, a fragment. \par
\b\f0\lang1033 FragmentTransactions\par
\b0 You replace the fragment at runtime inside a fragment transaction. A fragment transaction is a set of changes you want to apply relating to the fragment, all at the same time. To create a fragment transaction, you start by getting a FragmentTransaction from the fragment manager:\par
To Create a FragmentTransaction ,you start by getting a FragmentTransaction from the FragmentManager :\par
WorkoutDetailFragment fragment = new WorkoutDetailFragment();\par
FragmentTransaction transaction = getFragmentManager.beginTransaction();\par
You then specify all the actions you want to group together in the transaction. In our case, we want to replace the fragment in the frame layout, and we do this using the fragment\rquote s replace() method:\f3\lang9\par
\f0 transaction.replace(R.id.fragment_container,fragment);\par
Add a fragment - add\par
remove a fragment - remove\par
setTransition()\par
\par
\b addToBackStack\par
\b0 Once you\rquote ve specified all the actions you want to take as part of the transaction, you can use the addToBackStack() method to add the transaction to the back stack of transactions. \par
This allows the user to go back to a previous state of the fragment when they press the Back button. The addToBackStack() method takes one parameter, a String name you can use to label the transaction\par
transaction.addToBackStack(null);\par
To commit the changes to the activity, you call the commit() method: \par
transaction.commit();-- applies the changes.\par
\par
\b\fs28 chapter 7\par
\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b0 A fragment is used to control part of a screen. It can be reused across multiple activities. \par
{\pntext\f4\'B7\tab}A fragment has an associated layout.\par
{\pntext\f4\'B7\tab} A fragment is a subclass of the android.app.Fragment class. \par
{\pntext\f4\'B7\tab}The onCreateView() method gets called each time Android needs the fragment\rquote s layout. \par
{\pntext\f4\'B7\tab}Add a fragment to an activity\rquote s layout using the <fragment> element and adding a class attribute.\par
{\pntext\f4\'B7\tab}The fragment lifecycle methods tie in with the states of the activity that contains the fragment. \par
{\pntext\f4\'B7\tab}The Fragment class doesn\rquote t extend the Activity class or implement the Context class. \par
{\pntext\f4\'B7\tab}Fragments don\rquote t have a findViewById() method. Instead, use the getView() method to get a reference to the root view, then call the view\rquote s findViewById() method.\par
{\pntext\f4\'B7\tab}A list fragment is a fragment that comes complete with a ListView. You create one by subclassing ListFragment.\par
{\pntext\f4\'B7\tab}If you need to get a fragment to respond to changes in the user interface, use the <FrameLayout> element. \par
{\pntext\f4\'B7\tab}Use fragment transactions to make a set of changes to an existing fragment and add to the back stack. \par
{\pntext\f4\'B7\tab}Make apps look different on different devices by putting separate layouts in device-appropriate folders.\fs24\par

\pard\sa200\sl276\slmult1\par
\b Chapter 8\par
\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b0 If you nest fragments inside fragments, you need to add the nested fragment programmatically. \par
{\pntext\f4\'B7\tab}\par
{\pntext\f4\'B7\tab}To get the fragment manager that\rquote s associated with the parent fragment, you use the getChildFragmentManager() method. This means that the code to begin the transaction looks like this:\par
{\pntext\f4\'B7\tab}FragmentTransaction ft = getChildFragmentManager.beginTransaction();\par
{\pntext\f4\'B7\tab}So what difference does using getChildFragmentManager() make in practice? \cf1\b getFragmentManager() creates transactions at the activity lavel \par
{\pntext\f4\'B7\tab}\par
{\pntext\f4\'B7\tab}\cf0\b0 Fragments can contain other fragments.\par
{\pntext\f4\'B7\tab} If you\rquote re nesting a fragment in another fragment, you need to add the nested fragment programmatically in Java code. \par
{\pntext\f4\'B7\tab}When you perform transactions on a nested fragment, use getChildFragmentManager() to create the transaction. \par
{\pntext\f4\'B7\tab}If you use the android:onClick attribute in a fragment, Android will look for a method of that name in the fragment\rquote s parent activity. \par
{\pntext\f4\'B7\tab}Instead of using the android:onClick attribute in a fragment, make the fragment implement the View.OnClickListener interface and implement its onClick() method. \par
{\pntext\f4\'B7\tab}When the device configuration changes, the activity and its fragments get destroyed. When the activity is re-created, it replays its fragment transactions in the onCreate() method\rquote s call to setContentView(). \par
{\pntext\f4\'B7\tab}The fragment\rquote s onCreateView() method runs after the activity has replayed its fragment transactions.\par

\pard\sa200\sl276\slmult1\par
\par
Action Bar MenuItems\par
Add items to the ActionBar using\par
\b getMenuInflater.inflate(R.menu.main_menu , menu);\par
\b0 main_menu is the resource file created.\par
menu is a variable.\par
This method takes the menu items in the menu_main.xml resource file, adds them to the actionbar menu variable.\par
\par
\b Chapter 10\par
\par
Navigation Drawer\par
\par
\b0 A navigation drawer is a slide-out panel that contains links to the main parts of the app.\par
You implement a navigation drawer using a special type of layout called a DrawerLayout. \par
The DrawerLayout manages two views: \par
\b A view for the main content. This is usually a FrameLayout so that you can display and switch fragments. \par
A view for the navigation drawer, usually a ListView. \par
\b0 By default, the DrawerLayout displays the view containing the main content. It looks just like a normal activity\par
\par
Here are the steps we\rquote ll go through to do this: \par
1. Create fragments for the major hubs.\par
 2. Create and initialize the navigation drawer . The navigation drawer will contain a ListView displaying the list of options.\par
 3. Get the ListView to respond to item clicks. This will allow the user to navigate to the major hubs of the app.\par
 4. Add an ActionBarDrawerToggle. This lets the user control the drawer through the action bar and allows the activity to respond to drawer open and close events.\par
\b\par
\b0 Use a DrawerLayout to create an activity with a navigation drawer. Use the drawer to navigate to the major hubs of your app. \par
If you\rquote re using an action bar, use ActionBarDrawerToggle as a DrawerListener. This allows you to respond to the drawer opening and closing, and adds an icon to the action bar for opening and closing the drawer.\par
 To change action bar items at runtime, call invalidateOptionsMenu() and add the changes in the activity\rquote s onPrepareOptionsMenu() method. \par
React to changes on the back stack by implementing the FragmentManager.OnBackStackChangedListener(). \par
The fragment manager\rquote s findFragmentByTag() method searches for fragments with a given tag.\par
\par
\b Chapter 11\par
\b0 Android uses SQLLite databases to persist data.\par
Its lightweight.It is optimized for single user.\par
Its stable and fast.\par
Android automatically creates a folder for each app where the app\rquote s database can be stored. It will be stored in the /data/data/package name/databases folder.\par
Database directory is separate from the app's code.That way, the app can be overwritten with a newer version ,but the data in the database will be safe.\par
An app can store several databases in this folder. \par
Each database consists of two files. \par
The first file is the database file and has the same name as your database \f3\emdash  for example, \ldblquote starbuzz\rdblquote . This is the main SQLite database file. All of your data is stored in this file. \par
The second file is the journal file. It has the same name as your database, with a suffix of \ldblquote -journal\rdblquote  \emdash  for example, \ldblquote starbuzz-journal\rdblquote . The journal file contains all of the changes made to your database. If there\rquote s a problem, Android will use the journal to undo (or rollback) your latest changes. \f0\par
\b Android comes with SQLite classes.\b0\par
Android uses a set of classes that allows you to manage a SQLite database. There are three types of object that do the bulk of this work.\par
\b The SQLite Helper \b0 You create a SQLite helper by extending the SQLiteOpenHelper class. This enables you to create and manage databases\par
\b Cursors \b0 A Cursor lets you read from and write to the database. It\rquote s like a ResultSet in JDBC\par
\b The SQLite Database\b0  The SQLiteDatabase class gives you access to the database. It\rquote s like a SQLConnection in JDBC.\par
\b Create SQLLiteHelper\par
\b0 You create a SQLite helper by writing a class that extends the SQLiteOpenHelper class. When you do this, you must override the onCreate() and onUpgrade() methods. These methods are mandatory . \par
The\b  onCreate()\b0  method gets called when the database first gets created on the device. The method should include all the code needed to create the tables you need for your app. \par
The \b onUpgrade() \b0 method gets called when the database needs to be upgraded. As an example, if you need to make table changes to your database after it\rquote s been released, this is the method to do it in.\par
\par
\b 1. Specify the database \par
\b0 There are two pieces of information the SQLite helper needs in order to create the database.\par
First, we need to give the \b database a name\b0 . By giving the database a name, we make sure that the database remains on the device when it\rquote s closed. If we don\rquote t, the database will only be created in memory , so once the database is closed, it will disappear. \par
The second piece of information we need to provide is the \b version of the database\b0 . The database version needs to be an integer value, starting at 1. The SQLite helper uses this version number to determine whether the database needs to be upgraded.\par
NOTE Creating databases that are only held in memory can be useful when you\rquote re testing your app\par
You specify the database name and version by passing them to the constructor of the SQLiteOpenHelper superclass. \par
public class MyDatabaseHelper extends SQLLiteHelper\{\par
\par
\tab MyDatabaseHelper(Context context)   \{\par
\tab\tab super(context,"dbname",null,version_num);\par
       \}\par
\}\par
\par
The constructor specifies details of the database, but the database doesn\rquote t get created at that point. \par
The SQLite helper waits until the app needs to access the database, and the database gets created at that point. \par
Once you\rquote ve told the SQLite helper what database to create, you can specify its tables.\par
\b Primary Key coloumn naming Restriction in Android\par
\b0 It\rquote s an Android convention to call your primary key columns _id. Android code expects there to be an _id column on your data. Ignoring this convention will make it harder to get the data out of your database and into your user interface. \par
The \b onCreate() \b0 method is called when the database is created.\par
The SQLite helper is in charge of creating the SQLite database the first time it needs to be used. \par
First, an empty database is created on the device, and then the SQLite helper onCreate() method is called. \par
The onCreate() method is passed a SQLiteDatabase object as a parameter. We can use this to run our SQL command with the method:\par
SQLLiteDatabase.execSQL(String sql).\par
The SQLiteDatabase class gives you access to the database. This method has one parameter, the SQL you want to execute. \par
\b Insert Data using insert() method.\par
\b0 If you need to prepopulate a SQLite table with data, you can use the SQLiteDatabase insert() method. This method allows you to insert data into the database, and returns the ID of the record once it\rquote s been inserted. If the method is unable to insert the record, it returns a value of -1.\par
To use the insert() method, you need to specify the table you want to insert into, and the values you\rquote re inserting. \par
You say what values you want to insert by creating a ContentValues object. \b A ContentValues object is used to hold name/value pairs of data: \b0\par
\b ContentValues drinkValues = new ContentValues(); \par
\b0 You add name/value pairs of data to the ContentValues object using its put() method. \par
We want to use it to insert a row of data into the DRINK table, so we\rquote ll populate it with the name of each column in the DRINK table, and the value we want to go in each field:\b\par
\b0 drinkValues.put("Column name","value");\par
Finally, we\rquote ll use the SQLiteDatabase insert() method to insert the values into the DRINK \b table: db.insert("DRINK", null, drinkValues); \par
\b0 The insert() method takes the following general form:\par
db.insert(String tablename,String nullColoumnHack,ContentValues values)\par
The nullColumnHack String value is optional and most of the time you\rquote ll want to set it to null like we did in the code above\par
\b Update records with the update() method \par
\b0 You update existing records in SQLite using the SQLiteDatabase update() method.\par
 This method allows you to update records in the database, and returns the number of records it\rquote s updated. \par
To use the update() method, you need to specify the table you want to update records in, the values you want to update, and the conditions for updating them.\par
Here\rquote s what it looks like: \b public int update (String table, \par
                   ContentValues values, \par
                    String whereClause,                  \par
                   String[] whereArgs) \par
If you set the last two parameters of the update() method to null, ALL records in the table will be updated. As an example, the code db.update("DRINK",          drinkValues,          null, null); will update all records in the DRINK table.\par
\par
\par
CardView And Recycler Views\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b0 Card views and recycler views have their own support libraries. \par
{\pntext\f4\'B7\tab}Add a card view to a layout using the <android.support.v7.widget.CardView> element. \par
{\pntext\f4\'B7\tab}Give the card view rounded corners using the cardCornerRadius attribute. This requires a namespace of "{{\field{\*\fldinst{HYPERLINK http://schemas.android.com/apk/res-auto }}{\fldrslt{http://schemas.android.com/apk/res-auto\ul0\cf0}}}}\f0\fs24 ". \par
{\pntext\f4\'B7\tab}Recycler views work with adapters that are subclasses of RecyclerView.Adapter.\par
{\pntext\f4\'B7\tab} When you create your own RecyclerView.Adapter, you must define the ViewHolder and implement the onCreateViewHolder(), onBindViewHolder(), and getItemCount() methods.\par
{\pntext\f4\'B7\tab} You add a recycler view to a layout using the <android.support.v7.widget.RecyclerView> element. You give it a scrollbar using the android:scrollbars attribute. \par
{\pntext\f4\'B7\tab}Use a layout manager to specify how items in a recycler view should be arranged. A LinearLayoutManager arranges items in a linear list, a GridLayoutManager arranges items in a grid, and a StaggeredGridLayoutManager arranges items in a staggered grid.\b\par

\pard\sa200\sl276\slmult1\par
ViewPagers\b0  \par
Layout that allows the user to swipe left and right through "pages" of content which are usually different fragments. This is a common navigation mode to use instead of ActionBar Tabs with Fragments.\par
\par
\b A ViewPager is a layout which can be added to any layout XML file inside a root layout\b0 :\par
<?xml version="1.0" encoding="utf-8"?>\par
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"\par
    android:layout_width="match_parent"\par
    android:layout_height="match_parent"\par
    android:orientation="vertical">\par
     \b <android.support.v4.view.ViewPager\par
        android:id="@+id/vpPager"\par
        android:layout_width="match_parent"\par
        android:layout_height="wrap_content">\par
    </android.support.v4.view.ViewPager>\par
\b0 </LinearLayout>\par
\par
\b Steps:\par
1) Add a viewPager in the main layout\par
2) Define some fragments\par
3) Setup FragmentPageAdapter :  define the adapter that will properly determine how many pages exist and which fragment to display for each page of the adapter by creating a FragmentPagerAdapter\par
For more complex cases with many pages, check out the more dynamic approach with SmartFragmentStatePagerAdapter\par
\b0 Copy in the \b SmartFragmentStatePagerAdapter.java \b0 which provides the \b intelligent caching of registered fragments within our ViewPager\b0 . \b It does so by overriding the instantiateItem() method and caching any created fragments internally\b0 . This solves the common problem of needing to access the current item within the ViewPager.\par
\b\par
4) let's associate the ViewPager with a new instance of our adapter:\par
\b0 protected void onCreate(Bundle savedInstanceState) \{\par
\tab\tab super.onCreate(savedInstanceState);\par
\tab\tab setContentView(R.layout.activity_home);\par
\tab\tab\b ViewPager vpPager = (ViewPager) findViewById(R.id.vpPager);\par
\tab\tab adapterViewPager = new MyPagerAdapter(getSupportFragmentManager());\par
\tab\tab vpPager.setAdapter(adapterViewPager);\par
\tab\}\b0\par
\par
\par
\b ToolBar \par
\b0 Toolbar was introduced in Material Design in API level 21.\par
Toolbar\rquote s are more flexible than ActionBar. We can easily modify its color, size and position. We can also add labels, logos, navigation icons and other views in it.\par
Toolbar is implemented in the \b android.support.v7.widget.Toolbar \b0 class\par
Add the dependency design support library\par
\b Elements of the Toolbar\par
\b0 - Navigation Button\par
- Brand logo image\par
- title and sub title\par
- one or more custom views\par
- Action Menu\b\par
\par
Define in XML\par
<android.support.v7.widget.Toolbar\par
-- \par
</android.support.v7.widget.Toolbar>\par
\par
Setting Toolbar as An ActionBar:\par
\b0 We can easily replace ActionBar with Toolbar by using setSupportActionBar() method. Here is the code of replacing ActionBar with Toolbar.\par
\b Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); // get the reference of Toolbar\par
setSupportActionBar(toolbar); \b0 // Setting/replace toolbar as the ActionBar\par
\b\par
\b0\par
Now let\rquote s talk about the color scheme for our application. Open your color.xml file from values folder. In this XML file colorPrimary is the primary color for the app and colorPrimaryDark color is the color of the status bar. \b\par
\par
\par
NavigationDrawer\par
\par
\b0 Navigation Drawer is a panel that displays App\rquote s Navigation option from the left edge of the screen\par
Navigation drawer is a side menu that helps us to organise the navigation inside our app. \par
It is a uniform way to access different pages and information inside our app. \par
It is hidden most of the time but is revealed when we swipes from left edge of the screen or whenever we click on menu/app icon in the action bar.\par
\b DrawerLayout\par
\b0 DrawerLayout  acts as top level container for window content that allows for interactive \ldblquote drawer\rdblquote  views to be pulled out from one or both vertical edges of the window.\par
Drawer position and layout is controlled by using layout_gravity attribute on child views corresponding to which side of view we want the drawer to emerge from like left to right\par
\par
\b Basic DrawerLayout XML Code\par
\b0 For adding a Navigation Drawer, declare your UI with a \b DrawerLayout object as the root(parent) view of your layout.\par
\b0 Inside this  DrawerLayout add \par
a ) one view that contains the main content of the screen means primary layout that displays when the drawer is hidden\par
b) other view that contains the contents for the navigation drawer.\par
\b <android.support.v4.widget.DrawerLayout\par
    <!-- The main content view displays when the drawer is hidden -->\par
    <FrameLayout \par
    <!-- The navigation drawer -->\par
    <android.support.design.widget.NavigationView  \par
           app:menu="@menu/nav_items"/>\par
</android.support.v4.widget.DrawerLayout>\par
\b0\par
1) DrawerLayout is the root view of our Layout in which we have other layouts and content.\par
2) FrameLayout is used to hold the page content shown through different fragments.\par
3) The NavigationView is the \ldblquote real\rdblquote  menu of our app. The menu items are written in \b nav_items \b0 file.\par
\b Floating Labels in EditText\par
\b0 Floating labels first introduced in Android design support library to display floating label over EditText. \par
1)It acts as hint in the EditText when the field is empty. \par
2) When a user start inputting the text it starts animating by moving to floating label position.\par
<android.support.design.widget.TextInputLayout>\par
<EditText />\par
</android.support.design.widget.TextInputLayout>\par
\par
\b TabLayout\par
 1) \b0 It  provides horizontal layout to display tabs on the screen. \par
2) We can display more screens in a single screen using tabs. \par
3) We can quickly swipe between the tabs. \par
\b Note:\par
\b0 TabLayout is used to display tabs on the screen. \par
We can create sliding as well as non sliding tabs by using TabLayout.\par
 If we need simple tabs with\tab out sliding then we replace the layout with the fragment on tab selected listener event and if we need sliding tabs then we use Viewpager.\par
\b\fs36 RecyclerView As ListView\fs24\par
LayoutManager  - \b0 It contains the references for all the views that are filled by the data of the entry. We can create a Custom Layout Manager by extending RecyclerView.\par
LayoutManager Class of RecyclerView provides three types of in-built Layout Managers\par
    \b LinearLayoutManager\b0 : It is used for displaying vertical or horizontal list.\par
    \b GridLayoutManager\b0 : It is used for displaying the items in the form of Grids.\par
    \b StaggeredGridLayoutManager\b0 : It is used to show the items in staggered Grid (uneven size image in Grid).\par
\par
\b Cardview\par
\b0 CardView represents the information in a card manner with a drop shadow called elevation and corner radius which looks consistent across the platform. \par
A CardView is a ViewGroup that can be added in our Activity or Fragment using a layout XML file.\par
\par
\b SwipeRefreshLayout \par
\b0 This should be used whenever the user can refresh the contents of a view via a vertical swipe gesture.\par
This layout should be made the parent of the view that will be refreshed as a result of the gesture and can only support one direct child.\par
The Activity which instantiates SwipeRefreshLayout view should add an OnRefreshListener to be notified when the swipe to refresh gesture is completed. The Activity is responsible to handle the refresh event and refreshing the View. \par
\par
\b SnackBar\b0\par
Snackbars provide lightweight feedback about an operation. They show a brief message at the bottom of the screen on mobile and lower left on larger devices. Snackbars appear above all other elements on screen and only one can be displayed at a time\par
\b\par
\b0\par
\par
\par
\par
\par
\par
}
 